// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target arm64-apple-ios14.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name ParticleNetworkBase
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Base58_swift
import CryptoSwift
import Foundation
import RxSwift
import SafariServices
import Swift
import SwiftyJSON
import SwiftyUserDefaults
import UIKit
import _Concurrency
import _StringProcessing
@objc public enum SocialLoginPrompt : Swift.Int, Swift.RawRepresentable {
  case null
  case none
  case consent
  case selectAccount
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol AAServiceProtocol {
  func rpcGetSmartAccount(eoaAddresses: [Swift.String], chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<[AA.SmartAccountInfo]>
  func rpcGetFeeQuotes(eoaAddress: Swift.String, transactions: [Swift.String], chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<AA.WholeFeeQuote>
  func rpcCreateUserOp(eoaAddress: Swift.String, transactions: [Swift.String], feeQuote: AA.FeeQuote, tokenPaymasterAddress: Swift.String, chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<AA.UserOp>
  func rpcSendUserOp(eoaAddress: Swift.String, userOp: SwiftyJSON.JSON, chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<Swift.String>
  func isDeploy(eoaAddress: Swift.String, chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<Swift.Bool>
  func deployWalletContract(messageSigner: MessageSigner, feeMode: AA.FeeMode, chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<Swift.String>
  func isAAModeEnable() -> Swift.Bool
  func enableAAMode()
  func disableAAMode()
  func getSmartAccount(by eosAddress: Swift.String, chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<AA.SmartAccountInfo>
  func getSmartAccounts(by publicAddresses: [Swift.String], chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<[AA.SmartAccountInfo]>
  func quickSendTransactions(_ transactions: [Swift.String], feeMode: AA.FeeMode, messageSigner: MessageSigner, wholeFeeQuote: AA.WholeFeeQuote?, chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<Swift.String>
  func isSupportChainInfo(_ chainInfo: ParticleNetwork.ChainInfo) -> Swift.Bool
  func getSupportChainInfos() -> [ParticleNetwork.ChainInfo]
}
public protocol MessageSigner {
  func signMessage(_ message: Swift.String, chainInfo: ParticleNetwork.ChainInfo?) -> RxSwift.Single<Swift.String>
  func getEoaAddress() -> Swift.String
}
extension ParticleNetwork {
  public struct ResponseError : Swift.Codable, Swift.Equatable, Swift.Error, Swift.CustomStringConvertible {
    public let code: Swift.Int?
    public let message: Swift.String?
    public var data: Swift.String?
    public init(code: Swift.Int?, message: Swift.String?, data: Swift.String? = nil)
    public enum CodingKeys : Swift.String, Swift.CodingKey {
      case code, message, data
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    public init(from decoder: Swift.Decoder) throws
    public var description: Swift.String {
      get
    }
    public var localizedDescription: Swift.String {
      get
    }
    public static let requestRejected: ParticleNetwork.ResponseError
    public static let userCancel: ParticleNetwork.ResponseError
    public static let userNotLogin: ParticleNetwork.ResponseError
    public static let invalidRequest: ParticleNetwork.ResponseError
    public static let nullResult: ParticleNetwork.ResponseError
    public static func == (a: ParticleNetwork.ResponseError, b: ParticleNetwork.ResponseError) -> Swift.Bool
    public func encode(to encoder: Swift.Encoder) throws
  }
}
public typealias Limbs = [Swift.UInt64]
public typealias Limb = Swift.UInt64
public typealias Digits = [Swift.UInt64]
public typealias Digit = Swift.UInt64
public typealias Bytes = [Swift.UInt8]
public typealias Byte = Swift.UInt8
precedencegroup ExponentiationPrecedence {
  associativity: left
  higherThan: MultiplicationPrecedence
  lowerThan: BitwiseShiftPrecedence
}
infix operator ** : ExponentiationPrecedence
public struct BInt : Swift.SignedNumeric, Swift.BinaryInteger, Swift.ExpressibleByFloatLiteral, Swift.Codable {
  public typealias Magnitude = BInt
  public var magnitude: BInt {
    get
  }
  public typealias Words = [Swift.UInt]
  public var words: BInt.Words {
    get
  }
  public var size: Swift.Int {
    get
  }
  public var sizeDescription: Swift.String {
    get
  }
  public static var stringPrefixes: [Swift.Int : Swift.String]
  public init(_ z: Swift.Int)
  public init(_ n: Swift.UInt)
  public init?(_ number: Swift.String, radix: Swift.Int = 10)
  public init(floatLiteral value: Swift.Double)
  public init(integerLiteral value: Swift.Int)
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init<T>(_ source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(_ source: T) where T : Swift.BinaryInteger
  public init<T>(clamping source: T) where T : Swift.BinaryInteger
  public init?<T>(exactly source: T) where T : Swift.BinaryFloatingPoint
  public init<T>(truncatingIfNeeded source: T) where T : Swift.BinaryInteger
  public init(bytes: Bytes)
  public var description: Swift.String {
    get
  }
  public func asString(radix: Swift.Int) -> Swift.String
  public func asInt() -> Swift.Int?
  public var rawValue: (sign: Swift.Bool, limbs: [Swift.UInt64]) {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static var isSigned: Swift.Bool {
    get
  }
  public var bitWidth: Swift.Int {
    get
  }
  public func signum() -> BInt
  public var trailingZeroBitCount: Swift.Int {
    get
  }
  public func getBytes() -> Bytes
  public static func << <T>(lhs: BInt, rhs: T) -> BInt where T : Swift.BinaryInteger
  public static func <<= <T>(lhs: inout BInt, rhs: T) where T : Swift.BinaryInteger
  public static func >> <T>(lhs: BInt, rhs: T) -> BInt where T : Swift.BinaryInteger
  public static func >>= <T>(lhs: inout BInt, rhs: T) where T : Swift.BinaryInteger
  public static func & (lhs: BInt, rhs: BInt) -> BInt
  public static func &= (lhs: inout BInt, rhs: BInt)
  public static func | (lhs: BInt, rhs: BInt) -> BInt
  public static func |= (lhs: inout BInt, rhs: BInt)
  public static func ^ (lhs: BInt, rhs: BInt) -> BInt
  public static func ^= (lhs: inout BInt, rhs: BInt)
  prefix public static func ~ (x: BInt) -> BInt
  prefix public static func + (x: BInt) -> BInt
  public static func += (lhs: inout BInt, rhs: BInt)
  public static func + (lhs: BInt, rhs: BInt) -> BInt
  public static func + (lhs: Swift.Int, rhs: BInt) -> BInt
  public static func + (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func += (lhs: inout Swift.Int, rhs: BInt)
  public static func += (lhs: inout BInt, rhs: Swift.Int)
  public mutating func negate()
  prefix public static func - (n: BInt) -> BInt
  public static func - (lhs: BInt, rhs: BInt) -> BInt
  public static func - (lhs: Swift.Int, rhs: BInt) -> BInt
  public static func - (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func -= (lhs: inout BInt, rhs: BInt)
  public static func -= (lhs: inout Swift.Int, rhs: BInt)
  public static func -= (lhs: inout BInt, rhs: Swift.Int)
  public static func * (lhs: BInt, rhs: BInt) -> BInt
  public static func * (lhs: Swift.Int, rhs: BInt) -> BInt
  public static func * (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func *= (lhs: inout BInt, rhs: BInt)
  public static func *= (lhs: inout Swift.Int, rhs: BInt)
  public static func *= (lhs: inout BInt, rhs: Swift.Int)
  public static func ** (lhs: BInt, rhs: Swift.Int) -> BInt
  public static func ** (lhs: BInt, rhs: BInt) -> BInt
  public func factorial() -> BInt
  public func quotientAndRemainder(dividingBy rhs: BInt) -> (quotient: BInt, remainder: BInt)
  public static func / (lhs: BInt, rhs: BInt) -> BInt
  public static func /= (lhs: inout BInt, rhs: BInt)
  public static func % (lhs: BInt, rhs: BInt) -> BInt
  public static func %= (lhs: inout BInt, rhs: BInt)
  public static func == (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func < (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func > (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func <= (lhs: BInt, rhs: BInt) -> Swift.Bool
  public static func >= (lhs: BInt, rhs: BInt) -> Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public typealias Stride = Swift.Int
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public struct BDouble : Swift.ExpressibleByIntegerLiteral, Swift.ExpressibleByFloatLiteral, Swift.CustomStringConvertible, Swift.SignedNumeric, Swift.Comparable, Swift.Hashable, Swift.Codable {
  public var sign: Swift.Bool {
    get
  }
  public var numerator: Limbs {
    get
  }
  public var denominator: Limbs {
    get
  }
  public typealias Magnitude = Swift.Double
  public var magnitude: Swift.Double
  public init?<T>(exactly source: T) where T : Swift.BinaryInteger
  public init(_ src: BInt)
  public init(sign: Swift.Bool, numerator: Limbs, denominator: Limbs)
  public init(_ numerator: BInt, over denominator: BInt)
  public init(_ numerator: Swift.Int, over denominator: Swift.Int)
  public init?(_ numerator: Swift.String, over denominator: Swift.String)
  public init?(_ nStr: Swift.String)
  public init?(_ nStr: Swift.String, radix: Swift.Int)
  public init(_ z: Swift.Int)
  public init(_ d: Swift.Double)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public var description: Swift.String {
    get
  }
  public var fractionDescription: Swift.String {
    get
  }
  public static var precision: Swift.Int {
    get
    set
  }
  public var precision: Swift.Int {
    get
    set
  }
  public var decimalDescription: Swift.String {
    get
  }
  public func decimalExpansion(precisionAfterDecimalPoint precision: Swift.Int, rounded: Swift.Bool = true) -> Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public var size: Swift.Int {
    get
  }
  public var sizeDescription: Swift.String {
    get
  }
  public func rawData() -> (sign: Swift.Bool, numerator: [Swift.UInt64], denominator: [Swift.UInt64])
  public func isPositive() -> Swift.Bool
  public func isNegative() -> Swift.Bool
  public func isZero() -> Swift.Bool
  public mutating func minimize()
  public func rounded() -> BInt
  public func nthroot(_ root: Swift.Int) -> BDouble
  public func squareRoot() -> BDouble
  public static func + (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func + (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func + (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func + (lhs: BDouble, rhs: BInt) -> BDouble
  public static func + (lhs: BInt, rhs: BDouble) -> BDouble
  public static func += (lhs: inout BDouble, rhs: BDouble)
  public static func += (lhs: inout BDouble, rhs: Swift.Double)
  public mutating func negate()
  prefix public static func - (n: BDouble) -> BDouble
  public static func - (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func - (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func - (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func - (lhs: BDouble, rhs: BInt) -> BDouble
  public static func -= (lhs: inout BDouble, rhs: BDouble)
  public static func -= (lhs: inout BDouble, rhs: Swift.Double)
  public static func * (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func * (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func * (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func * (lhs: BDouble, rhs: BInt) -> BDouble
  public static func * (lhs: BInt, rhs: BDouble) -> BDouble
  public static func *= (lhs: inout BDouble, rhs: BDouble)
  public static func *= (lhs: inout BDouble, rhs: Swift.Double)
  public static func ** (base: BDouble, exponent: Swift.Int) -> BDouble
  public static func ** (base: BDouble, exponent: BInt) -> BDouble
  public static func ** (base: BDouble, exponent: BDouble) -> BDouble
  public static func / (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func / (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func / (lhs: BDouble, rhs: BInt) -> BDouble
  public static func / (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func % (lhs: BDouble, rhs: BDouble) -> BDouble
  public static func % (lhs: BDouble, rhs: Swift.Double) -> BDouble
  public static func % (lhs: Swift.Double, rhs: BDouble) -> BDouble
  public static func nearlyEqual(_ lhs: BDouble, _ rhs: BDouble, epsilon: Swift.Double = 0.00001) -> Swift.Bool
  public static func == (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func == (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func == (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func != (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func != (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func != (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func < (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func < (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func < (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func > (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func > (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func > (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func <= (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func <= (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func <= (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public static func >= (lhs: BDouble, rhs: BDouble) -> Swift.Bool
  public static func >= (lhs: BDouble, rhs: Swift.Double) -> Swift.Bool
  public static func >= (lhs: Swift.Double, rhs: BDouble) -> Swift.Bool
  public typealias FloatLiteralType = Swift.Double
  public typealias IntegerLiteralType = Swift.Int
  public func encode(to encoder: Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public func abs(_ x: BDouble) -> BDouble
public func floor(_ base: BDouble) -> BInt
public func ceil(_ base: BDouble) -> BInt
public func pow(_ base: BDouble, _ exp: Swift.Int) -> BDouble
public func pow(_ base: BDouble, _ exp: BInt) -> BDouble
public func pow(_ base: BDouble, _ exp: BDouble) -> BDouble
public func min(_ lhs: BDouble, _ rhs: BDouble) -> BDouble
public func max(_ lhs: BDouble, _ rhs: BDouble) -> BDouble
public func mod(_ lhs: BDouble, _ rhs: BDouble) -> BDouble
public protocol TxDataCodable : Swift.Decodable, Swift.Encodable {
  func serialize() throws -> Swift.String
  init?(_ hexString: Swift.String) throws
}
extension TxDataCodable {
  public func serialize() throws -> Swift.String
  public init?(_ hexString: Swift.String) throws
}
@objc public enum Action : Swift.Int, Swift.RawRepresentable, Swift.Codable {
  case normal
  case speedup
  case cancel
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum GasLevel : Swift.Int, Swift.RawRepresentable, Swift.Codable {
  case none = 0
  case custom
  case low
  case medium
  case high
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
@objc final public class FeeMarketEIP1559TxData : ObjectiveC.NSObject, Swift.Codable, TxDataCodable {
  final public let maxPriorityFeePerGas: Swift.String
  final public let maxFeePerGas: Swift.String
  final public let nonce: Swift.String
  final public let gasLimit: Swift.String
  final public var gas: Swift.String?
  final public let from: Swift.String
  final public let to: Swift.String?
  final public let value: Swift.String
  final public let data: Swift.String
  final public let chainId: Swift.String
  final public let type: Swift.String
  final public let v: Swift.String?
  final public let r: Swift.String?
  final public let s: Swift.String?
  final public let action: Swift.String
  final public let gasLevel: Swift.String?
  @objc public init(maxPriorityFeePerGas: Swift.String, maxFeePerGas: Swift.String, nonce: Swift.String = "0x0", gasLimit: Swift.String, from: Swift.String, to: Swift.String?, value: Swift.String, data: Swift.String, chainId: Swift.String, v: Swift.String? = nil, r: Swift.String? = nil, s: Swift.String? = nil, action: Action = Action.normal, gasLevel: GasLevel = GasLevel.none)
  @objc final public func serialize() throws -> Swift.String
  @objc public init(_ hexString: Swift.String) throws
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc final public class AccessListEIP2930TxData : ObjectiveC.NSObject, Swift.Codable, TxDataCodable {
  final public let gasPrice: Swift.String
  final public let accessList: AccessList?
  final public let nonce: Swift.String
  final public let gasLimit: Swift.String
  final public var gas: Swift.String?
  final public let from: Swift.String
  final public let to: Swift.String?
  final public let value: Swift.String
  final public let data: Swift.String
  final public let chainId: Swift.String
  final public let type: Swift.String
  final public let v: Swift.String?
  final public let r: Swift.String?
  final public let s: Swift.String?
  final public let action: Swift.String
  final public let gasLevel: Swift.String?
  @objc public init(gasPrice: Swift.String, accessList: AccessList?, nonce: Swift.String = "0x0", gasLimit: Swift.String, from: Swift.String, to: Swift.String?, value: Swift.String, data: Swift.String, chainId: Swift.String, v: Swift.String? = nil, r: Swift.String? = nil, s: Swift.String? = nil, action: Action = .normal, gasLevel: GasLevel = .none)
  @objc final public func serialize() throws -> Swift.String
  @objc public init(_ hexString: Swift.String) throws
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@objc public class AccessList : ObjectiveC.NSObject, Swift.Codable {
  @objc public init(address: Swift.String, storageKeys: [Swift.String])
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc final public class TxData : ObjectiveC.NSObject, Swift.Codable, TxDataCodable {
  final public let gasPrice: Swift.String
  final public let nonce: Swift.String
  final public let gasLimit: Swift.String
  final public var gas: Swift.String?
  final public let from: Swift.String
  final public let to: Swift.String?
  final public let value: Swift.String
  final public let data: Swift.String
  final public let chainId: Swift.String
  final public let type: Swift.String
  final public let v: Swift.String?
  final public let r: Swift.String?
  final public let s: Swift.String?
  final public let action: Swift.String
  final public let gasLevel: Swift.String?
  @objc public init(gasPrice: Swift.String, nonce: Swift.String = "0x0", gasLimit: Swift.String, from: Swift.String, to: Swift.String?, value: Swift.String, data: Swift.String, chainId: Swift.String, v: Swift.String? = nil, r: Swift.String? = nil, s: Swift.String? = nil, action: Action = .normal, gasLevel: GasLevel = .none)
  @objc final public func serialize() throws -> Swift.String
  @objc public init(_ hexString: Swift.String) throws
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public enum Language : Swift.String {
  case en
  case zh_Hans
  case zh_Hant
  case ja
  case ko
  public var localString: Swift.String {
    get
  }
  public var webString: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@frozen @objc public enum LoginType : Swift.Int, Swift.RawRepresentable {
  case email
  case phone
  case google
  case facebook
  case apple
  case twitter
  case discord
  case github
  case twitch
  case microsoft
  case linkedin
  case jwt
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public typealias Decimals = Swift.UInt8
public struct Request : Swift.Encodable {
  public init(method: Swift.String, params: [Swift.Encodable], id: Swift.String = UUID().uuidString, jsonrpc: Swift.String = "2.0")
  public func encode(to encoder: Swift.Encoder) throws
}
public struct EncodableWrapper : Swift.Encodable {
  public init(wrapped: Swift.Encodable)
  public func encode(to encoder: Swift.Encoder) throws
}
public struct Response<T> : Swift.Decodable where T : Swift.Decodable {
  public let chainId: Swift.Int?
  public let jsonrpc: Swift.String
  public let id: Swift.String?
  public let result: T?
  public var error: ParticleNetwork.ResponseError?
  public let method: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case chainId, jsonrpc, id, result, error, method
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: Swift.Decoder) throws
}
extension ParticleNetwork {
  @_hasMissingDesignatedInitializers @objc(ChainInfo) public class ChainInfo : ObjectiveC.NSObject {
    @objc final public let chainId: Swift.Int
    @objc final public let name: Swift.String
    @objc final public let chainType: ChainType
    @objc final public let chainIcon: Swift.String
    @objc final public let uiName: Swift.String
    @objc final public let network: Swift.String
    @objc final public let nativeCurrency: NativeCurrency
    @objc final public let explorePath: Swift.String
    @objc public static let ethereum: ParticleNetwork.ChainInfo
    @objc public static let ethereumGoerli: ParticleNetwork.ChainInfo
    @objc public static let optimism: ParticleNetwork.ChainInfo
    @objc public static let thunderCoreTestnet: ParticleNetwork.ChainInfo
    @objc public static let cronos: ParticleNetwork.ChainInfo
    @objc public static let bnbChain: ParticleNetwork.ChainInfo
    @objc public static let oktcTestnet: ParticleNetwork.ChainInfo
    @objc public static let oktc: ParticleNetwork.ChainInfo
    @objc public static let confluxeSpaceTestnet: ParticleNetwork.ChainInfo
    @objc public static let viction: ParticleNetwork.ChainInfo
    @objc public static let victionTestnet: ParticleNetwork.ChainInfo
    @objc public static let bnbChainTestnet: ParticleNetwork.ChainInfo
    @objc public static let gnosis: ParticleNetwork.ChainInfo
    @objc public static let solana: ParticleNetwork.ChainInfo
    @objc public static let solanaTestnet: ParticleNetwork.ChainInfo
    @objc public static let solanaDevnet: ParticleNetwork.ChainInfo
    @objc public static let thunderCore: ParticleNetwork.ChainInfo
    @objc public static let heco: ParticleNetwork.ChainInfo
    @objc public static let polygon: ParticleNetwork.ChainInfo
    @objc public static let manta: ParticleNetwork.ChainInfo
    @objc public static let x1Testnet: ParticleNetwork.ChainInfo
    @objc public static let opBNB: ParticleNetwork.ChainInfo
    @objc public static let mapProtocolTestnet: ParticleNetwork.ChainInfo
    @objc public static let fantom: ParticleNetwork.ChainInfo
    @objc public static let zkSyncEraTestnet: ParticleNetwork.ChainInfo
    @objc public static let kcc: ParticleNetwork.ChainInfo
    @objc public static let kccTestnet: ParticleNetwork.ChainInfo
    @objc public static let zkSyncEra: ParticleNetwork.ChainInfo
    @objc public static let cronosTestnet: ParticleNetwork.ChainInfo
    @objc public static let optimismGoerli: ParticleNetwork.ChainInfo
    @objc public static let pgn: ParticleNetwork.ChainInfo
    @objc public static let metisGoerli: ParticleNetwork.ChainInfo
    @objc public static let zoraGoerli: ParticleNetwork.ChainInfo
    @objc public static let klaytnTestnet: ParticleNetwork.ChainInfo
    @objc public static let confluxeSpace: ParticleNetwork.ChainInfo
    @objc public static let metis: ParticleNetwork.ChainInfo
    @objc public static let polygonzkEVM: ParticleNetwork.ChainInfo
    @objc public static let moonbeam: ParticleNetwork.ChainInfo
    @objc public static let moonriver: ParticleNetwork.ChainInfo
    @objc public static let moonbeamTestnet: ParticleNetwork.ChainInfo
    @objc public static let polygonzkEVMTestnet: ParticleNetwork.ChainInfo
    @objc public static let kavaTestnet: ParticleNetwork.ChainInfo
    @objc public static let kava: ParticleNetwork.ChainInfo
    @objc public static let fantomTestnet: ParticleNetwork.ChainInfo
    @objc public static let mantle: ParticleNetwork.ChainInfo
    @objc public static let mantleTestnet: ParticleNetwork.ChainInfo
    @objc public static let opBNBTestnet: ParticleNetwork.ChainInfo
    @objc public static let zetaChainTestnet: ParticleNetwork.ChainInfo
    @objc public static let klaytn: ParticleNetwork.ChainInfo
    @objc public static let base: ParticleNetwork.ChainInfo
    @objc public static let combo: ParticleNetwork.ChainInfo
    @objc public static let gnosisTestnet: ParticleNetwork.ChainInfo
    @objc public static let lumozzkEVMTestnet: ParticleNetwork.ChainInfo
    @objc public static let readONTestnet: ParticleNetwork.ChainInfo
    @objc public static let eosevmTestnet: ParticleNetwork.ChainInfo
    @objc public static let eosevm: ParticleNetwork.ChainInfo
    @objc public static let mapProtocol: ParticleNetwork.ChainInfo
    @objc public static let arbitrumOne: ParticleNetwork.ChainInfo
    @objc public static let arbitrumNova: ParticleNetwork.ChainInfo
    @objc public static let celo: ParticleNetwork.ChainInfo
    @objc public static let oasisEmeraldTestnet: ParticleNetwork.ChainInfo
    @objc public static let oasisEmerald: ParticleNetwork.ChainInfo
    @objc public static let avalancheTestnet: ParticleNetwork.ChainInfo
    @objc public static let avalanche: ParticleNetwork.ChainInfo
    @objc public static let celoTestnet: ParticleNetwork.ChainInfo
    @objc public static let pgnSepolia: ParticleNetwork.ChainInfo
    @objc public static let lineaGoerli: ParticleNetwork.ChainInfo
    @objc public static let linea: ParticleNetwork.ChainInfo
    @objc public static let polygonMumbai: ParticleNetwork.ChainInfo
    @objc public static let baseGoerli: ParticleNetwork.ChainInfo
    @objc public static let comboTestnet: ParticleNetwork.ChainInfo
    @objc public static let taikoJolnir: ParticleNetwork.ChainInfo
    @objc public static let platON: ParticleNetwork.ChainInfo
    @objc public static let arbitrumGoerli: ParticleNetwork.ChainInfo
    @objc public static let scrollSepolia: ParticleNetwork.ChainInfo
    @objc public static let scroll: ParticleNetwork.ChainInfo
    @objc public static let astarzkEVMTestnet: ParticleNetwork.ChainInfo
    @objc public static let platONTestnet: ParticleNetwork.ChainInfo
    @objc public static let mantaTestnet: ParticleNetwork.ChainInfo
    @objc public static let zora: ParticleNetwork.ChainInfo
    @objc public static let ethereumSepolia: ParticleNetwork.ChainInfo
    @objc public static let tron: ParticleNetwork.ChainInfo
    @objc public static let aurora: ParticleNetwork.ChainInfo
    @objc public static let auroraTestnet: ParticleNetwork.ChainInfo
    @objc public static let skaleNebula: ParticleNetwork.ChainInfo
    @objc public static let harmony: ParticleNetwork.ChainInfo
    @objc public static let harmonyTestnet: ParticleNetwork.ChainInfo
    @objc public static let tronShasta: ParticleNetwork.ChainInfo
    @objc public static let tronNile: ParticleNetwork.ChainInfo
    @objc deinit
  }
}
extension ParticleNetwork.ChainInfo {
  @objc public static func getChainInfo(chainId: Swift.Int, chainName: Swift.String) -> ParticleNetwork.ChainInfo?
  @objc public static func getEvmChain(chainId: Swift.Int) -> ParticleNetwork.ChainInfo?
  @objc public static func getSolanaChain(chainId: Swift.Int) -> ParticleNetwork.ChainInfo?
  @objc public static func getAllChains(comparator: ((ParticleNetwork.ChainInfo, ParticleNetwork.ChainInfo) -> Swift.Bool)? = nil) -> [ParticleNetwork.ChainInfo]
  @objc public static let defaultComparator: (_ a: ParticleNetwork.ChainInfo, _ b: ParticleNetwork.ChainInfo) -> Swift.Bool
  @objc public static var allNetworks: [ParticleNetwork.ChainInfo] {
    @objc get
  }
  @objc public static var bridgeableNetworks: [ParticleNetwork.ChainInfo]
  @objc public static var swapableNetworks: [ParticleNetwork.ChainInfo]
  @objc public static var fusionableNetworks: [ParticleNetwork.ChainInfo]
  @objc public static var didableNetworks: [ParticleNetwork.ChainInfo]
  public var isEvmChain: Swift.Bool {
    get
  }
  public var isSolanaChain: Swift.Bool {
    get
  }
  public var isMainnet: Swift.Bool {
    get
  }
  public var isSupportEIP1559: Swift.Bool {
    get
  }
  public var path: Swift.String {
    get
  }
  @objc dynamic public func getParticleNode(projectId: Swift.String, projectClientKey: Swift.String) -> Swift.String
  public var isSupportWalletConnect: Swift.Bool {
    get
  }
  public var isSupportBridge: Swift.Bool {
    get
  }
  public var isSupportSwap: Swift.Bool {
    get
  }
  public var isSupportFusion: Swift.Bool {
    get
  }
  public var isSupportDid: Swift.Bool {
    get
  }
  public var nativeTokenIcon: Swift.String {
    get
  }
  public var isTron: Swift.Bool {
    get
  }
}
@objc public enum ChainType : Swift.Int, Swift.RawRepresentable, Swift.Codable {
  case solana
  case evm
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct SecurityAccountConfig : Swift.Encodable {
  public var promptSettingWhenSign: Swift.Int
  public var promptMasterPasswordSettingWhenLogin: Swift.Int
  public init(promptSettingWhenSign: Swift.Int = 1, promptMasterPasswordSettingWhenLogin: Swift.Int = 0)
  public func encode(to encoder: Swift.Encoder) throws
}
final public class User : Swift.Codable, Swift.Equatable, SwiftyUserDefaults.DefaultsSerializable {
  final public let token: Swift.String
  final public let uuid: Swift.String
  final public let deviceId: Swift.String
  final public let wallets: [Wallet]
  final public var securityAccount: SecurityAccount?
  final public var avatar: Swift.String?
  final public var createdAt: Swift.String?
  final public var updateAt: Swift.String?
  final public var email: Swift.String?
  final public var appleEmail: Swift.String?
  final public var appleId: Swift.String?
  final public var facebookEmail: Swift.String?
  final public var facebookId: Swift.String?
  final public var googleEmail: Swift.String?
  final public var googleId: Swift.String?
  final public var name: Swift.String?
  final public var phone: Swift.String?
  final public var twitterId: Swift.String?
  final public var twitterEmail: Swift.String?
  final public var discordId: Swift.String?
  final public var discordEmail: Swift.String?
  final public var githubId: Swift.String?
  final public var githubEmail: Swift.String?
  final public var twitchId: Swift.String?
  final public var twitchEmail: Swift.String?
  final public var microsoftId: Swift.String?
  final public var microsoftEmail: Swift.String?
  final public var linkedinId: Swift.String?
  final public var linkedinEmail: Swift.String?
  final public var thirdParty: ThirdParty?
  final public var signature: Swift.String?
  final public var message: Swift.String?
  public init(from decoder: Swift.Decoder) throws
  public init(deviceId: Swift.String, token: Swift.String, uuid: Swift.String, wallets: [Wallet])
  public static func == (lhs: User, rhs: User) -> Swift.Bool
  public struct UserSnakeCase : Swift.Codable {
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[User]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<User>
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
}
final public class SecurityAccount : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable {
  final public var email: Swift.String?
  final public var phone: Swift.String?
  final public var hasSetPaymentPassword: Swift.Bool
  final public var hasSetMasterPassword: Swift.Bool
  public init(email: Swift.String?, phone: Swift.String?, hasSetPaymentPassword: Swift.Bool, hasSetMasterPassword: Swift.Bool)
  public init(from decoder: Swift.Decoder) throws
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[SecurityAccount]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<SecurityAccount>
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
}
final public class Wallet : Swift.Encodable, Swift.Decodable, Swift.Equatable, SwiftyUserDefaults.DefaultsSerializable {
  final public let uuid: Swift.String
  final public let chainName: Swift.String
  final public let publicAddress: Swift.String
  public static func == (lhs: Wallet, rhs: Wallet) -> Swift.Bool
  public init(uuid: Swift.String, chainName: Swift.String, publicAddress: Swift.String)
  public init(from decoder: Swift.Decoder) throws
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[Wallet]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<Wallet>
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
}
final public class ThirdParty : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable {
  final public var provider: Swift.String?
  final public var userInfo: ThirdParty.UserInfo?
  public class UserInfo : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable {
    public var id: Swift.String?
    public var name: Swift.String?
    public var email: Swift.String?
    public var picture: Swift.String?
    public init(id: Swift.String?, name: Swift.String?, email: Swift.String?, picture: Swift.String?)
    required public init(from decoder: Swift.Decoder) throws
    public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[ThirdParty.UserInfo]>
    public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<ThirdParty.UserInfo>
    @objc deinit
    public func encode(to encoder: Swift.Encoder) throws
  }
  public init(provider: Swift.String?, userInfo: ThirdParty.UserInfo?)
  public init(from decoder: Swift.Decoder) throws
  public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[ThirdParty]>
  public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<ThirdParty>
  @objc deinit
  final public func encode(to encoder: Swift.Encoder) throws
}
@objc public class UserInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc public var token: Swift.String
  @objc final public let uuid: Swift.String
  @objc final public let wallets: [WalletInfo]
  @objc public var securityAccount: SecurityAccountInfo?
  @objc final public let avatar: Swift.String?
  @objc final public let createdAt: Swift.String?
  @objc final public let updatedAt: Swift.String?
  @objc final public let email: Swift.String?
  @objc final public let appleEmail: Swift.String?
  @objc final public let appleId: Swift.String?
  @objc final public let facebookEmail: Swift.String?
  @objc final public let facebookId: Swift.String?
  @objc final public let googleEmail: Swift.String?
  @objc final public let googleId: Swift.String?
  @objc final public let name: Swift.String?
  @objc final public let phone: Swift.String?
  @objc public var twitterId: Swift.String?
  @objc public var twitterEmail: Swift.String?
  @objc final public let discordId: Swift.String?
  @objc final public let discordEmail: Swift.String?
  @objc final public let githubId: Swift.String?
  @objc final public let githubEmail: Swift.String?
  @objc final public let twitchId: Swift.String?
  @objc final public let twitchEmail: Swift.String?
  @objc final public let microsoftId: Swift.String?
  @objc final public let microsoftEmail: Swift.String?
  @objc final public let linkedinId: Swift.String?
  @objc final public let linkedinEmail: Swift.String?
  @objc public var thirdParty: ThirdPartyWarpper?
  @objc public var signature: Swift.String?
  @objc public var message: Swift.String?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case uuid, phone, email, name, avatar, signature, message
    case createdAt
    case updatedAt
    case facebookId
    case facebookEmail
    case googleId
    case googleEmail
    case appleId
    case appleEmail
    case twitterId
    case twitterEmail
    case discordId
    case discordEmail
    case githubId
    case githubEmail
    case twitchId
    case twitchEmail
    case microsoftId
    case microsoftEmail
    case linkedinId
    case linkedinEmail
    case thirdParty
    case wallets
    case token
    case securityAccount
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  @objc public init(token: Swift.String, uuid: Swift.String, wallets: [WalletInfo], securityAccount: SecurityAccountInfo?, avatar: Swift.String?, createdAt: Swift.String?, updatedAt: Swift.String?, email: Swift.String?, appleEmail: Swift.String?, appleId: Swift.String?, facebookEmail: Swift.String?, facebookId: Swift.String?, googleEmail: Swift.String?, googleId: Swift.String?, name: Swift.String?, phone: Swift.String?, twitterId: Swift.String?, twitterEmail: Swift.String?, discordId: Swift.String?, discordEmail: Swift.String?, githubId: Swift.String?, githubEmail: Swift.String?, twitchId: Swift.String?, twitchEmail: Swift.String?, microsoftId: Swift.String?, microsoftEmail: Swift.String?, linkedinId: Swift.String?, linkedinEmail: Swift.String?, thirdParty: ThirdPartyWarpper?, signature: Swift.String?, message: Swift.String?)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  public func convertToSnakeCase() -> User.UserSnakeCase
  public func jsonStringFullSnake() -> Swift.String
  public func jsonStringSnake() -> Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class SecurityAccountInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc public var email: Swift.String?
  @objc public var phone: Swift.String?
  @objc public var hasSetPaymentPassword: Swift.Bool
  @objc public var hasSetMasterPassword: Swift.Bool
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case email, phone
    case hasSetMasterPassword
    case hasSetPaymentPassword
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  @objc public init(email: Swift.String?, phone: Swift.String?, hasSetPaymentPassword: Swift.Bool, hasSetMasterPassword: Swift.Bool)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class WalletInfo : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let uuid: Swift.String
  @objc final public let chainName: Swift.String
  @objc final public let publicAddress: Swift.String
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case uuid
    case chainName
    case publicAddress
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  required public init(from decoder: Swift.Decoder) throws
  @objc public init(uuid: Swift.String, chainName: Swift.String, publicAddress: Swift.String)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
}
@objc public class ThirdPartyWarpper : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let provider: Swift.String?
  @objc final public let userInfo: ThirdPartyUserInfoWarpper?
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case provider
    case userInfo
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  @objc public init(provider: Swift.String?, userInfo: ThirdPartyUserInfoWarpper?)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
@objc public class ThirdPartyUserInfoWarpper : ObjectiveC.NSObject, Swift.Codable {
  @objc final public let id: Swift.String?
  @objc final public let name: Swift.String?
  @objc final public let email: Swift.String?
  @objc final public let picture: Swift.String?
  @objc public init(id: Swift.String?, name: Swift.String?, email: Swift.String?, picture: Swift.String?)
  @objc override dynamic public var description: Swift.String {
    @objc get
  }
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public var navigationBarHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) public class var topMost: UIKit.UIViewController? {
    get
  }
}
@objc public class LoginAuthorization : ObjectiveC.NSObject {
  final public let message: Swift.String?
  final public let isUnique: Swift.Bool?
  public init(message: Swift.String?, isUnique: Swift.Bool?)
  @objc deinit
}
public enum TronFormatAddress {
  public static func toHex(_ base58String: Swift.String) -> Swift.String
  public static func fromHex(_ hexString: Swift.String) -> Swift.String
}
@_inheritsConvenienceInitializers @objc public class ParticleNetwork : ObjectiveC.NSObject {
  @objc public static let sdkVersion: Swift.String
  public static var projectUuid: Swift.String {
    get
  }
  public static var projectClientKey: Swift.String {
    get
  }
  public static var projectAppUuid: Swift.String {
    get
  }
  @objc public static func initialize(config: ParticleNetworkConfiguration)
  @objc public static func initializeWithOptions(_ options: ParticleOptions, config: ParticleNetworkConfiguration)
  public static func setAAService(_ aaService: AAServiceProtocol)
  public static func getAAService() -> AAServiceProtocol?
  @objc public static func getChainInfo() -> ParticleNetwork.ChainInfo
  @objc public static func getDevEnv() -> ParticleNetwork.DevEnvironment
  @objc public static func setChainInfo(_ chainInfo: ParticleNetwork.ChainInfo)
  public static func setAppearance(_ style: UIKit.UIUserInterfaceStyle)
  public static func getAppearance() -> UIKit.UIUserInterfaceStyle
  public static func setThemeColor(_ color: UIKit.UIColor)
  public static func getThemeColor() -> UIKit.UIColor
  public static func setLanguage(_ language: Language)
  public static func getLanguage() -> Language
  public static func setFiatCoin(_ fiatCoin: FiatCoin)
  public static func getFiatCoin() -> FiatCoin?
  public static func setSecurityAccountConfig(config: SecurityAccountConfig)
  public static func getSecurityAccountConfig() -> SecurityAccountConfig
  public static func setAAAccountName(_ accountName: AA.AccountName)
  public static func getAAAccountName() -> AA.AccountName
  @objc override dynamic public init()
  @objc deinit
}
extension ParticleNetwork {
  @available(*, deprecated, renamed: "setAppearance")
  @objc public static func setInterfaceStyle(_ style: UIKit.UIUserInterfaceStyle)
  @available(*, deprecated, renamed: "getAppearance")
  @objc public static func getInterfaceStyle() -> UIKit.UIUserInterfaceStyle
}
@objc public class ParticleNetworkConfiguration : ObjectiveC.NSObject {
  @objc public init(chainInfo: ParticleNetwork.ChainInfo, devEnv: ParticleNetwork.DevEnvironment)
  @objc deinit
}
extension ParticleNetwork {
  @objc public enum DevEnvironment : Swift.Int {
    case debug
    case staging
    case production
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension ParticleNetwork {
  public static func searchChainInfo(by chainId: Swift.Int, chainType: ChainType) -> ParticleNetwork.ChainInfo?
}
public enum Constant {
  public enum Regex {
    public static let base58PublicKey: Swift.String
    public static let base58String: Swift.String
    public static let evmAddress: Swift.String
    public static let tronAddress: Swift.String
    public static let hexString: Swift.String
    public static let email: Swift.String
    public static let phoneNumber: Swift.String
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class Constants : ObjectiveC.NSObject {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class Regexs : ObjectiveC.NSObject {
    @objc public class func base58PublicKey() -> Swift.String
    @objc public class func base58String() -> Swift.String
    @objc public class func evmAddress() -> Swift.String
    @objc public class func hexString() -> Swift.String
    @objc public class func email() -> Swift.String
    @objc public class func phoneNumber() -> Swift.String
    @objc deinit
  }
  @objc deinit
}
extension Foundation.TimeZone {
  public func offsetFromGMT() -> Swift.String
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ParticleOptions : ObjectiveC.NSObject {
  public init(projectUuid: Swift.String, projectClientKey: Swift.String, projectAppUuid: Swift.String)
  @objc deinit
}
extension Swift.String {
  public func urlEncoded() -> Swift.String
  public func urlDecoded() -> Swift.String
}
extension Swift.String {
  public var isAlphanumeric: Swift.Bool {
    get
  }
  public var isNumber: Swift.Bool {
    get
  }
  public var isDoubleNumber: Swift.Bool {
    get
  }
  public func isValidAddress() -> Swift.Bool
  public func isValidMessage() -> Swift.Bool
  public func isValidEmail() -> Swift.Bool
  public func isValidPhoneNumber() -> Swift.Bool
}
extension Swift.String {
  public func isValidSolanaAddress() -> Swift.Bool
  public func isValidEVMAddress() -> Swift.Bool
  public func isValidBase58String() -> Swift.Bool
  public func isValidHexString() -> Swift.Bool
  public func isValidTronAddress() -> Swift.Bool
}
extension Swift.Array where Element : Swift.Equatable {
  public mutating func appendIfNotExist(_ el: Element?)
  public mutating func appendOrReplace(_ el: Element?)
  public mutating func replace(_ el: Element?)
}
extension Swift.Int {
  public func toHexString() -> Swift.String
  public func toDateString() -> Swift.String
}
extension Swift.String {
  public func toBInt() -> BInt
  public func toChecksumAddress() -> Swift.String
}
extension BInt {
  public func convertToBalance(decimals: Swift.Int?) -> Swift.Double
  public func convertToBalance(decimals: Swift.UInt8?) -> Swift.Double
  public func convertToBalanceBDouble(decimals: Swift.UInt8?) -> BDouble
  public func toHexString() -> Swift.String
  public func convertToScientific() -> Swift.String
}
extension BDouble {
  public func convertToScientific() -> Swift.String
  public func convertToBalance(decimals: Swift.Int?) -> Swift.Double
  public func convertToBalance(decimals: Swift.UInt8?) -> Swift.Double
}
@_hasMissingDesignatedInitializers @objc(NativeCurrency) public class NativeCurrency : ObjectiveC.NSObject {
  @objc final public let name: Swift.String
  @objc final public let symbol: Swift.String
  @objc final public let decimals: Swift.Int
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class SupportAuthType : ObjectiveC.NSObject {
  public var rawValue: Swift.String
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc public static var all: SupportAuthType {
    @objc get
  }
  @objc public static var google: SupportAuthType {
    @objc get
  }
  @objc public static var facebook: SupportAuthType {
    @objc get
  }
  @objc public static var apple: SupportAuthType {
    @objc get
  }
  @objc public static var twitter: SupportAuthType {
    @objc get
  }
  @objc public static var discord: SupportAuthType {
    @objc get
  }
  @objc public static var github: SupportAuthType {
    @objc get
  }
  @objc public static var twitch: SupportAuthType {
    @objc get
  }
  @objc public static var microsoft: SupportAuthType {
    @objc get
  }
  @objc public static var linkedin: SupportAuthType {
    @objc get
  }
  @objc public static var email: SupportAuthType {
    @objc get
  }
  @objc public static var phone: SupportAuthType {
    @objc get
  }
  @objc deinit
}
public enum LogEvent : Swift.String {
  case error
  case response
  case authService
  case walletService
  case connectService
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class Logger {
  public static var isEnableLogger: Swift.Bool
  open class func log(message: Any, event: LogEvent, tag: Swift.String, fileName: Swift.String = #file, line: Swift.Int = #line, column: Swift.Int = #column, funcName: Swift.String = #function, apiMethod: Swift.String? = nil)
  public class func activeLog(data: Foundation.Data)
  public class func recordLog(data: Foundation.Data)
  public struct RecordObject : Swift.Encodable {
    public init(recordType: Logger.RecordType)
    public enum CodingKeys : Swift.String, Swift.CodingKey {
      case recordType
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    public func encode(to encoder: Swift.Encoder) throws
  }
  public enum RecordType : Swift.String, Swift.Encodable {
    case pageLoginButtonClick
    case pageLoginSuccessBack
    case pageSignSuccessBack
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct ActiveObject : Swift.Encodable {
    public enum CodingKeys : Swift.String, Swift.CodingKey {
      case loginType
      case chainId
      case identity
      case walletAddress
      case action
      case userInfo
      public init?(rawValue: Swift.String)
      public init?(stringValue: Swift.String)
      public init?(intValue: Swift.Int)
      public typealias RawValue = Swift.String
      public var intValue: Swift.Int? {
        get
      }
      public var rawValue: Swift.String {
        get
      }
      public var stringValue: Swift.String {
        get
      }
    }
    public init(activeLoginType: Logger.ActiveLoginType, identity: Swift.String, walletAddress: Swift.String, activeActionType: Logger.ActiveActionType, userInfo: Swift.String?)
    public func encode(to encoder: Swift.Encoder) throws
  }
  public enum ActiveActionType : Swift.String {
    case login
    case open
    case openWallet
    case sign
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ActiveLoginType : Swift.String {
    case particle
    case private_key
    case metamask
    case rainbow
    case trust
    case imToken
    case bitKeep
    case phantom
    case other
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
public struct CustomUIConfig : Swift.Decodable {
  public var light: ModeConfig?
  public var dark: ModeConfig?
  public init(from decoder: Swift.Decoder) throws
}
extension CustomUIConfig {
  public var primaryColor: UIKit.UIColor? {
    get
  }
  public var accentColor: UIKit.UIColor? {
    get
  }
  public var onPrimaryColor: UIKit.UIColor? {
    get
  }
  public var primaryButtonTextColor: UIKit.UIColor? {
    get
  }
  public var primaryButtonBackgroundColors: [UIKit.UIColor]? {
    get
  }
  public var primaryIconButtonBackgroundColors: [UIKit.UIColor]? {
    get
  }
  public var primaryIconButtonIconColor: UIKit.UIColor? {
    get
  }
  public var cancelButtonBackgroundColor: UIKit.UIColor? {
    get
  }
  public var toastColor: (UIKit.UIColor?, UIKit.UIColor?) {
    get
  }
  public var maskColor: UIKit.UIColor? {
    get
  }
}
public struct ModeConfig : Swift.Decodable {
  public var colorAccent: Swift.String?
  public var colorPrimary: Swift.String?
  public var colorOnPrimary: Swift.String?
  public var primaryButtonBackgroundColors: [Swift.String]?
  public var primaryButtonTextColor: Swift.String?
  public var primaryIconButtonIconColor: Swift.String?
  public var primaryIconButtonBackgroundColors: [Swift.String]?
  public var cancelButtonBackgroundColor: Swift.String?
  public var messageColor: [Swift.String]?
  public var modalMaskBackgroundColor: Swift.String?
  public init(from decoder: Swift.Decoder) throws
}
public enum AA {
  @frozen public struct AccountName : Swift.Equatable, Swift.Codable, Swift.Hashable {
    public let version: Swift.String
    public let name: Swift.String
    public var walletName: Swift.String {
      get
    }
    public init(version: Swift.String, name: Swift.String)
    public static let biconomyV2: AA.AccountName
    public static let biconomyV1: AA.AccountName
    public static let simple: AA.AccountName
    public static let cyberConnect: AA.AccountName
    public var image: UIKit.UIImage {
      get
    }
    public var isSupportBatchTx: Swift.Bool {
      get
    }
    public var supportChainIds: Swift.Set<Swift.Int> {
      get
    }
    public static func == (a: AA.AccountName, b: AA.AccountName) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public func encode(to encoder: Swift.Encoder) throws
    public var hashValue: Swift.Int {
      get
    }
    public init(from decoder: Swift.Decoder) throws
  }
  public struct AccountConfig : Swift.Codable {
    public var name: Swift.String
    public var version: Swift.String
    public var biconomyApiKey: Swift.String?
    public var ownerAddress: Swift.String
    public init(name: Swift.String, version: Swift.String, ownerAddress: Swift.String, biconomyApiKey: Swift.String? = nil)
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  @frozen public enum FeeMode {
    case native
    case gasless
    case token(AA.FeeQuote)
  }
  public struct SmartAccountInfo : Swift.Codable, SwiftyUserDefaults.DefaultsSerializable, Swift.Equatable {
    public var isDeployed: [Swift.Int : Swift.Bool]
    public var eoaAddress: Swift.String
    public var factoryAddress: Swift.String
    public var entryPointAddress: Swift.String
    public var smartAccountAddress: Swift.String
    public var fallBackHandlerAddress: Swift.String?
    public var implementationAddress: Swift.String?
    public var owner: Swift.String
    public var name: Swift.String
    public var version: Swift.String
    public var index: Swift.Int
    public init(from decoder: Swift.Decoder) throws
    public init(isDeployed: [Swift.Int : Swift.Bool], eoaAddress: Swift.String, smartAccountAddress: Swift.String, index: Swift.Int, createdAt: Swift.String, updatedAt: Swift.String, entryPointAddress: Swift.String, factoryAddress: Swift.String, fallBackHandlerAddress: Swift.String, implementationAddress: Swift.String, owner: Swift.String, name: Swift.String, version: Swift.String)
    public init(from json: SwiftyJSON.JSON)
    public static func == (lhs: AA.SmartAccountInfo, rhs: AA.SmartAccountInfo) -> Swift.Bool
    public mutating func merge(_ other: AA.SmartAccountInfo)
    public typealias ArrayBridge = SwiftyUserDefaults.DefaultsCodableBridge<[AA.SmartAccountInfo]>
    public typealias Bridge = SwiftyUserDefaults.DefaultsCodableBridge<AA.SmartAccountInfo>
    public func encode(to encoder: Swift.Encoder) throws
  }
  public struct FeeQuote {
    public struct TokenInfo {
      public var chainId: Swift.Int
      public var symbol: Swift.String
      public var name: Swift.String
      public var decimals: Decimals
      public var logoURI: Swift.String
      public var address: Swift.String
      public var isNative: Swift.Bool {
        get
      }
    }
    public var tokenInfo: AA.FeeQuote.TokenInfo
    public var premiumPercentage: Swift.Int
    public var balance: BInt
    public var fee: BInt
    public var tokenPaymasterAddress: Swift.String?
    public var jsonObject: [Swift.String : SwiftyJSON.JSON]
    public init(json: SwiftyJSON.JSON, tokenPaymasterAddress: Swift.String?)
    public var isEnoughForPay: Swift.Bool {
      get
    }
  }
  public struct UserOp : Swift.Codable {
    public var userOp: SwiftyJSON.JSON
    public var userOpHash: Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  public struct WholeFeeQuote : Swift.Codable {
    public var gasless: AA.VerifyingPaymasterGasless?
    public var native: AA.VerifyingPaymasterNative
    public var token: AA.TokenPaymaster?
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  public struct VerifyingPaymasterGasless : Swift.Codable {
    public var userOp: SwiftyJSON.JSON
    public var userOpHash: Swift.String
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  public struct VerifyingPaymasterNative : Swift.Codable {
    public var userOp: SwiftyJSON.JSON
    public var userOpHash: Swift.String
    public var feeQuote: SwiftyJSON.JSON
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
  public struct TokenPaymaster : Swift.Codable {
    public var tokenPaymasterAddress: Swift.String
    public var feeQuotes: [SwiftyJSON.JSON]
    public func encode(to encoder: Swift.Encoder) throws
    public init(from decoder: Swift.Decoder) throws
  }
}
public enum FiatCoin : Swift.String {
  case usd
  case cny
  case jpy
  case hkd
  case inr
  case krw
  public var symbol: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension ParticleNetwork {
  public static var authEndPoint: Swift.String {
    get
  }
  public static var apiEndPoint: Swift.String {
    get
  }
  public static var nodeEndPoint: Swift.String {
    get
  }
  public static var webWalletEndPoint: Swift.String {
    get
  }
  public static var authCoreEndPoint: Swift.String {
    get
  }
}
extension SocialLoginPrompt : Swift.Equatable {}
extension SocialLoginPrompt : Swift.Hashable {}
extension ParticleNetwork.ResponseError.CodingKeys : Swift.Equatable {}
extension ParticleNetwork.ResponseError.CodingKeys : Swift.Hashable {}
extension ParticleNetwork.ResponseError.CodingKeys : Swift.RawRepresentable {}
extension Action : Swift.Equatable {}
extension Action : Swift.Hashable {}
extension GasLevel : Swift.Equatable {}
extension GasLevel : Swift.Hashable {}
extension Language : Swift.Equatable {}
extension Language : Swift.Hashable {}
extension Language : Swift.RawRepresentable {}
extension LoginType : Swift.Equatable {}
extension LoginType : Swift.Hashable {}
extension LoginType : Swift.Sendable {}
extension Response.CodingKeys : Swift.Equatable {}
extension Response.CodingKeys : Swift.Hashable {}
extension Response.CodingKeys : Swift.RawRepresentable {}
extension ChainType : Swift.Equatable {}
extension ChainType : Swift.Hashable {}
extension UserInfo.CodingKeys : Swift.Equatable {}
extension UserInfo.CodingKeys : Swift.Hashable {}
extension UserInfo.CodingKeys : Swift.RawRepresentable {}
extension SecurityAccountInfo.CodingKeys : Swift.Equatable {}
extension SecurityAccountInfo.CodingKeys : Swift.Hashable {}
extension SecurityAccountInfo.CodingKeys : Swift.RawRepresentable {}
extension WalletInfo.CodingKeys : Swift.Equatable {}
extension WalletInfo.CodingKeys : Swift.Hashable {}
extension WalletInfo.CodingKeys : Swift.RawRepresentable {}
extension ThirdPartyWarpper.CodingKeys : Swift.Equatable {}
extension ThirdPartyWarpper.CodingKeys : Swift.Hashable {}
extension ThirdPartyWarpper.CodingKeys : Swift.RawRepresentable {}
extension ParticleNetwork.DevEnvironment : Swift.Equatable {}
extension ParticleNetwork.DevEnvironment : Swift.Hashable {}
extension ParticleNetwork.DevEnvironment : Swift.RawRepresentable {}
extension LogEvent : Swift.Equatable {}
extension LogEvent : Swift.Hashable {}
extension LogEvent : Swift.RawRepresentable {}
extension Logger.RecordObject.CodingKeys : Swift.Equatable {}
extension Logger.RecordObject.CodingKeys : Swift.Hashable {}
extension Logger.RecordObject.CodingKeys : Swift.RawRepresentable {}
extension Logger.RecordType : Swift.Equatable {}
extension Logger.RecordType : Swift.Hashable {}
extension Logger.RecordType : Swift.RawRepresentable {}
extension Logger.ActiveObject.CodingKeys : Swift.Equatable {}
extension Logger.ActiveObject.CodingKeys : Swift.Hashable {}
extension Logger.ActiveObject.CodingKeys : Swift.RawRepresentable {}
extension Logger.ActiveActionType : Swift.Equatable {}
extension Logger.ActiveActionType : Swift.Hashable {}
extension Logger.ActiveActionType : Swift.RawRepresentable {}
extension Logger.ActiveLoginType : Swift.Equatable {}
extension Logger.ActiveLoginType : Swift.Hashable {}
extension Logger.ActiveLoginType : Swift.RawRepresentable {}
extension AA.AccountName : Swift.Sendable {}
extension FiatCoin : Swift.Equatable {}
extension FiatCoin : Swift.Hashable {}
extension FiatCoin : Swift.RawRepresentable {}
